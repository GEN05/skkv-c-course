# Директивы препроцессора. Макроопределения.

## Препроцессор
Препроцессор - это программа, которая преобразует исходный код в код понятный компилятору. В языке С/С++ препроцессор удаляет комментарии, преобразует код в соответствии с макросами и выполняет директивы препроцессора.

## Директивы препроцессора

### Директива препроцессора `include`

Директива препроцессора `include` тупо копирует содержимое файла в место, где была прописана эта директива.

a.h
````C
int f() {
    return 1;
}
````
a.c до препроцессинга
````C
#include "a.h"

int g() {
    return f();
}
````
a.c после препроцессинга
````C
int f() {
    return 1;
}

int g() {
    return f();
}
````

### Директива препроцессора `define` и макросы

Директива препроцессора `define` создает макрос, который представляет из себя правило конвертации идентификатора в указанный токен.

Макросы бывают двух типов: макросы-объекты и макросы-функции

#### Макросы-объекты

Макросы-объекты можно создать двумя способами:
````C
#define <идентификатор>
#define <идентификатор> <заменяющий текст>
````
Обратите внимание: макросы не заканчиваются точкой с запятой, так как это директивы препроцессора, а не выражения языка Си.

##### Макросы с заменяющим текстом

Если присутствует макрос с заменяющим текстом, то любое появление идентификатора заменяется заменяющим текстом.

Пример 1:

a.c до препроцессинга
````C
#define PI 3.141592

double circle_area(double r) {
    return PI * r * r;
}
````

a.c до препроцессинга
````C
double circle_area(double r) {
    return 3.141592 * r * r;
}
````

Пример 2:
a.c до препроцессинга
````C
#define CINT_PTR const int *

void f (CINT_PTR p);
````

a.c после препроцессинга
````C
void f (const int* p);
````

##### Макросы без заменяющего текста

Макросы без заменяющего текста работают так же как и макросы с заменяющим текстом:
когда препроцессор встречает идентификтор, то он заменит его НИЧЕМ. Может показаться, что такие макросы бесполезны, но их основная задача заключается в другом. Зачем? Будет понятно позже (спойлер: htader-guard и условная компиляция). 

#### Макросы-функции

Макросы-функции ведут себя так же как функции и используются как функции))) Они имеют следующий вид:
````C
#define <идентификатор>(аргумент1, аргумент2, ...) <тело>
````

Вообще, считается, что использование макрос-функций - это плохой тон, так как их использование может быть опасным и код с кучей макрос-функций сложнее дебажить.

Пример:

a.c до препроцессинга
````C
#define PI 3.141592
#define AREA(R) PI * R * R

int f() {
    return AREA(3);
}
````
a.c после препроцессинга
````C
int f() {
    return 3.141592 * 3 * 3;
}
````
Если макрос очень большой, то можно сделать его в несколько строк, но придется каждую строчку заменять символом "`\`":
````C
#define SUM (A, B) do {\
    return A + B;\
} while(0)

int sum(int a, int b) {
    SUM(a, b);
}
````

#### Директива `undef`

Директива препроцессора `undef` удаляет макрос, созданный до этого с помощью директивы `define`

### Директивы препроцессорa `if`, `ifdef` и прочие

Директива препроцессора `if` работает так: если выражение стоящее сразу после директивы `if` имеет ненулевое значение, то группа строк до директивы `endif` сохраняется препроцессором, иначе строчки между `if` и `endif` сохранены не будут, и в код скопмилированной программы их не будет.

Пример:

a.c до препроцессинга
````C
#define DEBUG 1

int f(int x) {
#if DEBUG > 0
    printf("%i", x);
#endif    
    return (x + 2) * 2;
}
````
a.c после препроцессинга
````C
int f(int x) {
    printf("%i", x); 
    return (x + 2) * 2;
}
````
a.c после препроцессинга, если убрать строчку `#define DEBUG 1`
````C
int f(int x) {
    return (x + 2) * 2;
}
````

Данный код можно упростить с помощью директив препроцессора `ifdef`, `ifndef`
Они проверяют, был и до этого определен макрос с таким идентификатором. 

Пример:

a.c до препроцессинга
````C
#define DEBUG
#define WIN64


int f(int x) {
#ifdef DEBUG
    printf("%i", x);
#endif

#ifdef WIN64    
    return win64func(x);
#endif

#ifdef WIN32
    return win32func(x);
#endif   
}
````

a.c после препроцессинга
````C
int f(int x) {
    printf("%i", x); 
    return win64func(x);
}
````

Данный подход называется условной компиляцией. Хорошим примерном условной компиляции является такая штука, как header guard. Когда в проекте очень много заголовочных файлов, может случится такое, что один заголовочный файл будет подключен в один файл .c несколько раз, это приведет к дублированию определений.

Пример:

math.h
````C
double circle_area(double r) {
    return PI * r * r;
}
````

geometry.h
````C
#include "math.h"
double cylinder_volume(double r, double h) {
    return circle_area(r) * h;
}
````

a.c
````C
#include <stdio.h>
#include "math.h"
#include "geometry.h"

void print_cylinder_data(double r, double h) {
    printf("Площадь основания: %lf", сircle_area(r));
    printf("Объем: %lf", cylinder_volume(r, h));
}
````
a.c после препроцессинга
````C
#include <stdio.h>
double circle_area(double r) { // из math.h
    return PI * r * r;
}

double circle_area(double r) { // из geometry.h
    return PI * r * r;
}

double cylinder_volume(double r, double h) {
    return circle_area(r) * h;
}

void print_cylinder_data(double x) {
    printf("Площадь основания: %lf", сircle_area(x));
    printf("Объем: %lf", cylinder_volume(x));
}
````

Как можно заметить, функция circle_area была определена дважды, что привело к ошибки компиляции - компилятор не знает какую функцию из них надо юзать. Даную проблему можно решить с помощью header_guard:
math.h
````C
#ifndef MATH_H
#define MATH_H
double circle_area(double r) {
    return PI * r * r;
}
#endif
````

geometry.h
````C
#ifndef GEOMETRY_H
#define GEOMETRY_H
#include "math.h"
double cylinder_volume(double r, double h) {
    return circle_area(r) * h;
}
#endif
````

a.c
````C
#include <stdio.h>
#include "math.h"
#include "geometry.h"

void print_cylinder_data(double r, double h) {
    printf("Площадь основания: %lf", сircle_area(r));
    printf("Объем: %lf", cylinder_volume(r, h));
}
````

a.c после препроцессинга
````C
#include <stdio.h>
double circle_area(double r) { // из math.h
    return PI * r * r;
}

double cylinder_volume(double r, double h) { // из geometry.h
    return circle_area(r) * h;
}

void print_cylinder_data(double x) {
    printf("Площадь основания: %lf", сircle_area(x));
    printf("Объем: %lf", cylinder_volume(x));
}
````

Как это работает? Когда препроцессор подключает заголовочный файл он проверит: был ли определен идентификатор `MATH_H`. Если такой идентификатор препроцессору встретился впервые, то он определит этот идентификатор, а дальше вставит содержимой файла `math.h`. Если такой идентификатор ранее встречался препроцессору, то содержимое файла будет проигнорировано.

В настоящее время большинство компиляторов поддерживает альтернативу header guards - директиву `#pragma once`. Вместо того чтобы писать аж три строчки кода (!) можно написать только одну строчку `#pragma once` в начале заголовочного файла. Однако `#pragma once` не является официальной частью языка С и не все компиляторы ее поддерживают (хотя большинство поддерживает), поэтому чтобы сохранить переносимость вашего кода, лучше использовать header guards.

### Директива препроцессора `error`

Директива препроцессора `error` выдает указанную ошибку компиляции и завершает компиляцию

Пример:
````C
#ifndef SOME_IMPORTANT_MACRO
#error Need an important macro!
#endif
````