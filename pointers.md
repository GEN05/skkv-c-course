# Типы данных и их объявление. Указатели. Адресная арифметика.

Указатель - это переменная которая хранит в себе адрес объекта. Он не хранит информацию о содержимом объекта, а только хранит информацию о том, где расположен объект.

Общий вид объявления указателей:
`<тип> *имя`

Тип указателя - это тип переменной, адрес которой он содержит.

Для работы работы с указателями в Си определены две операции
- `*` - взятие значения по адресу (разыменовывание)
- `&` - определение адреса объекта

Пример:
````C
int a = 0;
int* p = &a; // значение `p` = адрес `a`
(*p)++;      // увеличили значение переменной `a` на единицу 
````
Я тут операцию `*p` взял в круглые скобки, так как один раз напоролся на багу (когда писал лабораторную), что сначала инкрементился адрес на единицу, а потом только бралось значение. В данном примере нам надо наоборот - взять значение и увеличить его на единицу.

## Приколюхи с const

Мы можем использовать const вместе с указателями, при чем всякими разными способами:
````C
int* p; // Обычный указатель
const int* cp; // Указатель на константное значение. Значение самого указателя мы поменять можем, но поменять значение по адресу, на который указывает указатель - нет
int const* cp2; // То же самое что и предыдущее.
int* const pc; // Константный указатель на неконстантное значение. Значение самого указателя мы поменять не можем, а вот поменять значение по адресу, на который указывает указатель - можем.
const int* const cpc; // Константный указатель на константное значение. Ничего менять не можем 
````

Замечание: указатель на константное значение может указывать только на константу!
````C
int a;
const int const_a;

const int* cptr = &const_a; // OK!
cptr = &a; // Ошибка! Невозможно конвертировать `const int*` в `int*`
````
## Указатель на void
В случае, если нам заранее неизвестно указатель какого типа нам приходится использовать (например, неизвестно какой указатель придет как аргумент функции) мы можем использовать нетипизированный указатель (void *)
````C
void f(void *p) {
    int a = *((int *)p);
}
Обратите внимание: при разыменовывании нетипизированного указателя, вам надо явно привести его к нужному типу, как это показано в примере выше.
````
## Адресная арифметика

С указателями можно производить арифметические операции, почти так же как с обычными переменными. Использование таких операций называется адресной арифметикой или арифметикой указателей.

### Сложение с числом, вычитание и инкермент/декремент
При сложении указателя с числом, его значение увеличивается (уменьшается) на величину, кратную размеру типа (в байтах), на который он указывает.
````C
int32_t* p = 0; // int32_t занимает 8 бит = 1 байт
p++;    // p = 4
p += 4; // p = 20
````
Вычитание работает аналогично сложению

Обратите внимание: умножения и деления указателей на число и на другие указатели - ну существует

Обратите внимание: арифметика с указателями не может быть применена к нетипизированным указателям, поскольку такие указатели не хранят информации о размере типа, на который они указывают, соответственно, неизвестно на какое число надо увеличивать адрес, например при инкременте.

### Вычитание между указателями
Помимо сложения и вычитания с числом мы можем провести вычитание одного указателя из другого. 

В результате вычитания получается число элементов базового типа, находящихся между указателями.

Это может быть удобно, например, если мы хотим узнать число элементов в массиве находящихся между двумя известными объектами.

Для хранения результатов такого вычитания существует специальный тип: `ptrdiff_t`
````C
ptrdiff_t range_number(int *a, int* b) {
    if (a > b) {
        swap(a, b);
    }
    return b - a;
} // Вернет количество объектов находящихся между объектами a и b
````