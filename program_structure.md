# Cтруктура программы на языке С. Прототипы функций. Модульное построение программы.

Любая программа на языке Си состоит из набора директив препроцессора,
определений функций и глобальных объектов.

## Фукнция main
Точкой входа в программу является функция `main()` которая возвращает значение типа `int` операционной системе. Функция `main` может принимать
в себя некоторые аргументы:
````C
int main(int argc, char** argv, char** env) {
    return 0;
}
````
Здесь `argc` - это количество аргументов командной строки,
`argv` - массив С-строк - аргументы командной строки (Обратите внимание: 
argv[0] - название исполняемого файла),
`env` - так же как и `argv` содержит массив строк, но содержит переменные среды.

## Прототипы функций
Рассмотрим такой код:
````C
int f() {
    return square(2);
}

int square(int a) {
    return a * a;
}
````
Данный код не скомпилируется, потому что на момент вызова `square(2)` компилятор не знает о существовании функции `square`. Решить эту проблему можно с помощью предварительного объявления.

````C
int square(int); // Имя аргумента здесь можно опустить

int f() {
    return square(2);
}

int square(int a) {
    return a * a;
}
````
Предварительное объявление позволяет сообщить компилятору о существовании идентификатора до его фактического определения. В случае функции мы можем сделать это с помощью прототипа функции. В данном примере `int square(int);` - это прототип функции. Прототип функции состоит из типа возвращаемого значения, имени функции и типов её параметров. 

## Модульное построение программы
Модульное программирование — это организация программы как совокупности небольших независимых блоков, называемых модулями.

Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом.

В языке С модуль представляет из себя совокупность интерфейса (заголовочного файла .h) и реализации (файла .с). 

Интерфейс содержит в себе предварительные объявления функций, структур, констант. А реализация содержит реализацию :D.

Пример:

hello.h
````C
#ifndef HELLO_H
#define HELLO_H

void hello();

#endif // HELLO_H
````
hello.c
````C
#include "hello.h"
#include <stdio.h>
void hello() {
    printf("Hello!\n");
}
````
main.c
````C
#include "hello.h"
int main(int argc, char** argv) {
    hello();
    return 0;
}
````
Возможный вопрос: Почему нужно отделять интерфейс в заголовочном файле от
реализации в файле .c? Не легче ли запихнуть всю реализацию в заголовочный файл и радоваться жизни?
Ответ: Нет, не легче. В случае, если мы будем пихать всю реализацию в хедеры,
может быть такое, что где-то в коде программы после обработки перпроцессором встретится повторное определение, например, функции. Компилер выдаст ошибку.


Зачем нужно модульное программирование? Представьте, что программа состоит из одного модуля на десятки тысяч строк кода. Тогда, при изменений кода в одной строчке, приходилось бы перекомпилировать ВСЮ программу, а это процесс не быстрый. В случае разделения на модули, изменения в код вносить гораздо легче, так как нам нужно будет перекомпилировать только тот модуль, в который мы внесли изменения. Такое раздельное компилирование возможно за счет существования такой штуки как компоновщик (линкер) - он склеивает несколько объектных файлов (Объектный файл - результат компиляции одного файла .с) в один исполняемый файл. 